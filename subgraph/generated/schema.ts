// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ClaimSubmit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_transactionID", Value.fromBigInt(BigInt.zero()));
    this.set("_claimID", Value.fromBigInt(BigInt.zero()));
    this.set("_receiver", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ClaimSubmit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ClaimSubmit entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ClaimSubmit", id.toString(), this);
    }
  }

  static load(id: string): ClaimSubmit | null {
    return changetype<ClaimSubmit | null>(store.get("ClaimSubmit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _transactionID(): BigInt {
    let value = this.get("_transactionID");
    return value!.toBigInt();
  }

  set _transactionID(value: BigInt) {
    this.set("_transactionID", Value.fromBigInt(value));
  }

  get _claimID(): BigInt {
    let value = this.get("_claimID");
    return value!.toBigInt();
  }

  set _claimID(value: BigInt) {
    this.set("_claimID", Value.fromBigInt(value));
  }

  get _receiver(): Bytes {
    let value = this.get("_receiver");
    return value!.toBytes();
  }

  set _receiver(value: Bytes) {
    this.set("_receiver", Value.fromBytes(value));
  }
}

export class Dispute extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_arbitrator", Value.fromBytes(Bytes.empty()));
    this.set("_disputeID", Value.fromBigInt(BigInt.zero()));
    this.set("_metaEvidenceID", Value.fromBigInt(BigInt.zero()));
    this.set("_evidenceGroupID", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Dispute entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Dispute entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Dispute", id.toString(), this);
    }
  }

  static load(id: string): Dispute | null {
    return changetype<Dispute | null>(store.get("Dispute", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _arbitrator(): Bytes {
    let value = this.get("_arbitrator");
    return value!.toBytes();
  }

  set _arbitrator(value: Bytes) {
    this.set("_arbitrator", Value.fromBytes(value));
  }

  get _disputeID(): BigInt {
    let value = this.get("_disputeID");
    return value!.toBigInt();
  }

  set _disputeID(value: BigInt) {
    this.set("_disputeID", Value.fromBigInt(value));
  }

  get _metaEvidenceID(): BigInt {
    let value = this.get("_metaEvidenceID");
    return value!.toBigInt();
  }

  set _metaEvidenceID(value: BigInt) {
    this.set("_metaEvidenceID", Value.fromBigInt(value));
  }

  get _evidenceGroupID(): BigInt {
    let value = this.get("_evidenceGroupID");
    return value!.toBigInt();
  }

  set _evidenceGroupID(value: BigInt) {
    this.set("_evidenceGroupID", Value.fromBigInt(value));
  }
}

export class Evidence extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_arbitrator", Value.fromBytes(Bytes.empty()));
    this.set("_evidenceGroupID", Value.fromBigInt(BigInt.zero()));
    this.set("_party", Value.fromBytes(Bytes.empty()));
    this.set("_evidence", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Evidence entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Evidence entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Evidence", id.toString(), this);
    }
  }

  static load(id: string): Evidence | null {
    return changetype<Evidence | null>(store.get("Evidence", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _arbitrator(): Bytes {
    let value = this.get("_arbitrator");
    return value!.toBytes();
  }

  set _arbitrator(value: Bytes) {
    this.set("_arbitrator", Value.fromBytes(value));
  }

  get _evidenceGroupID(): BigInt {
    let value = this.get("_evidenceGroupID");
    return value!.toBigInt();
  }

  set _evidenceGroupID(value: BigInt) {
    this.set("_evidenceGroupID", Value.fromBigInt(value));
  }

  get _party(): Bytes {
    let value = this.get("_party");
    return value!.toBytes();
  }

  set _party(value: Bytes) {
    this.set("_party", Value.fromBytes(value));
  }

  get _evidence(): string {
    let value = this.get("_evidence");
    return value!.toString();
  }

  set _evidence(value: string) {
    this.set("_evidence", Value.fromString(value));
  }
}

export class HasToPayFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_transactionID", Value.fromBigInt(BigInt.zero()));
    this.set("_party", Value.fromI32(0));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HasToPayFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save HasToPayFee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("HasToPayFee", id.toString(), this);
    }
  }

  static load(id: string): HasToPayFee | null {
    return changetype<HasToPayFee | null>(store.get("HasToPayFee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _transactionID(): BigInt {
    let value = this.get("_transactionID");
    return value!.toBigInt();
  }

  set _transactionID(value: BigInt) {
    this.set("_transactionID", Value.fromBigInt(value));
  }

  get _party(): i32 {
    let value = this.get("_party");
    return value!.toI32();
  }

  set _party(value: i32) {
    this.set("_party", Value.fromI32(value));
  }
}

export class MetaEvidence extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_metaEvidenceID", Value.fromBigInt(BigInt.zero()));
    this.set("_evidence", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MetaEvidence entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save MetaEvidence entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("MetaEvidence", id.toString(), this);
    }
  }

  static load(id: string): MetaEvidence | null {
    return changetype<MetaEvidence | null>(store.get("MetaEvidence", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _metaEvidenceID(): BigInt {
    let value = this.get("_metaEvidenceID");
    return value!.toBigInt();
  }

  set _metaEvidenceID(value: BigInt) {
    this.set("_metaEvidenceID", Value.fromBigInt(value));
  }

  get _evidence(): string {
    let value = this.get("_evidence");
    return value!.toString();
  }

  set _evidence(value: string) {
    this.set("_evidence", Value.fromString(value));
  }
}

export class MetaTransactionExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userAddress", Value.fromBytes(Bytes.empty()));
    this.set("relayerAddress", Value.fromBytes(Bytes.empty()));
    this.set("functionSignature", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MetaTransactionExecuted entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save MetaTransactionExecuted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("MetaTransactionExecuted", id.toString(), this);
    }
  }

  static load(id: string): MetaTransactionExecuted | null {
    return changetype<MetaTransactionExecuted | null>(
      store.get("MetaTransactionExecuted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userAddress(): Bytes {
    let value = this.get("userAddress");
    return value!.toBytes();
  }

  set userAddress(value: Bytes) {
    this.set("userAddress", Value.fromBytes(value));
  }

  get relayerAddress(): Bytes {
    let value = this.get("relayerAddress");
    return value!.toBytes();
  }

  set relayerAddress(value: Bytes) {
    this.set("relayerAddress", Value.fromBytes(value));
  }

  get functionSignature(): Bytes {
    let value = this.get("functionSignature");
    return value!.toBytes();
  }

  set functionSignature(value: Bytes) {
    this.set("functionSignature", Value.fromBytes(value));
  }
}

export class Payment extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_transactionID", Value.fromBigInt(BigInt.zero()));
    this.set("_amount", Value.fromBigInt(BigInt.zero()));
    this.set("_receiver", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Payment entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Payment entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Payment", id.toString(), this);
    }
  }

  static load(id: string): Payment | null {
    return changetype<Payment | null>(store.get("Payment", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _transactionID(): BigInt {
    let value = this.get("_transactionID");
    return value!.toBigInt();
  }

  set _transactionID(value: BigInt) {
    this.set("_transactionID", Value.fromBigInt(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value!.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _receiver(): Bytes {
    let value = this.get("_receiver");
    return value!.toBytes();
  }

  set _receiver(value: Bytes) {
    this.set("_receiver", Value.fromBytes(value));
  }
}

export class Refund extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_transactionID", Value.fromBigInt(BigInt.zero()));
    this.set("_amount", Value.fromBigInt(BigInt.zero()));
    this.set("_party", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Refund entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Refund entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Refund", id.toString(), this);
    }
  }

  static load(id: string): Refund | null {
    return changetype<Refund | null>(store.get("Refund", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _transactionID(): BigInt {
    let value = this.get("_transactionID");
    return value!.toBigInt();
  }

  set _transactionID(value: BigInt) {
    this.set("_transactionID", Value.fromBigInt(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value!.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _party(): Bytes {
    let value = this.get("_party");
    return value!.toBytes();
  }

  set _party(value: Bytes) {
    this.set("_party", Value.fromBytes(value));
  }
}

export class Ruling extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_arbitrator", Value.fromBytes(Bytes.empty()));
    this.set("_disputeID", Value.fromBigInt(BigInt.zero()));
    this.set("_ruling", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Ruling entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Ruling entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Ruling", id.toString(), this);
    }
  }

  static load(id: string): Ruling | null {
    return changetype<Ruling | null>(store.get("Ruling", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _arbitrator(): Bytes {
    let value = this.get("_arbitrator");
    return value!.toBytes();
  }

  set _arbitrator(value: Bytes) {
    this.set("_arbitrator", Value.fromBytes(value));
  }

  get _disputeID(): BigInt {
    let value = this.get("_disputeID");
    return value!.toBigInt();
  }

  set _disputeID(value: BigInt) {
    this.set("_disputeID", Value.fromBigInt(value));
  }

  get _ruling(): BigInt {
    let value = this.get("_ruling");
    return value!.toBigInt();
  }

  set _ruling(value: BigInt) {
    this.set("_ruling", Value.fromBigInt(value));
  }
}
